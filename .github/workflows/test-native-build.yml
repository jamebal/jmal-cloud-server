# 可复用工作流：单次（某一组编译参数+镜像标签）的单架构构建、推送
on:
  workflow_call:
    inputs:
      image_tag:
        description: "本次构建的镜像标签（会生成 tag-arch 以及 tag 的多架构 manifest）"
        required: true
        type: string
      image_name:
        description: "本次构建的镜像名称（会生成 tag-arch 以及 tag 的多架构 manifest）"
        required: true
        type: string
      profiles_active:
        description: "--spring.profiles.active"
        required: true
        type: string
      aot_build_mode:
        description: "最终 Native Image 构建时的 -Daot.build.mode 参数"
        required: true
        type: string
      arch:
        description: "架构类型 (amd64 或 arm64)"
        required: true
        type: string
      node_version:
        description: "Node.js 版本"
        required: false
        type: string
        default: "16.20.2"
      graal_version:
        description: "GraalVM Java 版本"
        required: false
        type: string
        default: "24"
      dockerfile:
        description: "Dockerfile 路径（相对仓库根目录）"
        required: false
        type: string
        default: "./Dockerfile"
    secrets:
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true
      GHCR_IO_USERNAME:
        required: true
      GHCR_IO_TOKEN:
        required: true
      MONGODB_URI:
        required: true

jobs:
  # Job 1: 在自托管 runner 上构建 Native Image（只做编译）
  build-native-image:
    runs-on: ${{ inputs.arch == 'amd64' && fromJSON('["self-hosted", "Linux", "X64"]') || fromJSON('["self-hosted", "Linux", "ARM64"]') }}
    outputs:
      cache-dir: ${{ steps.save-cache.outputs.cache-dir }}

    steps:
      - name: Cleanup old failed caches
        run: |
          echo "Cleaning up caches older than 24 hours..."
          find /tmp/github-actions-build-cache -type d -mtime +1 -exec rm -rf {} + 2>/dev/null || true
          echo "Old caches cleaned up"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set Maven Environmental
        run: |
          echo "/opt/maven/bin" >> $GITHUB_PATH

      - name: Set up GraalVM environment
        run: |
          GRAALVM_VERSION="${{ inputs.graal_version }}"
          GRAALVM_HOME="/opt/graalvm-jdk-${GRAALVM_VERSION}"

          if [ ! -d "$GRAALVM_HOME" ]; then
            echo "Error: GraalVM $GRAALVM_VERSION not installed"
            exit 1
          fi

          echo "JAVA_HOME=$GRAALVM_HOME" >> $GITHUB_ENV
          echo "$GRAALVM_HOME/bin" >> $GITHUB_PATH

      - name: Check Maven version
        run: mvn -v

      # 构建带插桩的 Native Image
      - name: Build Instrumented Native Image
        run: |
          mvn clean package -Pnative -Daot.build.mode=${{ inputs.aot_build_mode }} -DskipTests -Dnative-image.jvmArgs="-Xmx23g" -Dnative-image.addArgs="--pgo-instrument -o target/jmalcloud-instrumented"

      # 运行插桩程序以生成 Profile 文件
      - name: Run Instrumented App to Generate Profile
        env:
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          HOME_DIR: ${{ env.HOME }}
        run: |
          chmod +x target/jmalcloud-instrumented
          
          rm -rf ${HOME}/jmalcloud
          rm -f jmalcloud.iprof
          
          mkdir -p ${HOME}/jmalcloud
          
          echo "Starting instrumented application in the background..."
          ./target/jmalcloud-instrumented --spring.profiles.active=${{ inputs.profiles_active }} -XX:ProfilesDumpFile='jmalcloud.iprof' --spring.data.mongodb.uri=${{secrets.MONGODB_URI}} --file.rootDir=${HOME}/jmalcloud > "${HOME}/app.log" 2>&1 &
          
          APP_PID=$!
          echo "应用程序已启动，进程ID为: $APP_PID"
          
          # 等待应用启动
          for i in {1..30}; do
            if curl -s http://localhost:8088/public/health | grep -q '^UP'; then
              echo "App is up"
              break
            fi
            sleep 2
          done
          
          # 创建管理员
          curl --location --request POST 'http://localhost:8088/api/public/initialization?password=123456&id=&username=admin&showName=%E7%AE%A1%E7%90%86%E5%91%981&avatar=https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&slogan=&introduction=&webpDisabled=&roles=&quota=10'
          # 上传文件
          cp -r target/test-classes ${HOME}/jmalcloud/admin/
          
          # 等待应用程序运行一段时间以收集性能数据
          echo "等待应用程序运行 120 秒以收集性能数据..."
          sleep 120
          
          # 打印日志文件的最后 100 行
          tail -n 100 "${HOME}/app.log"
          
          echo "发送 SIGINT 信号来优雅地终止进程，这会触发 profile 文件的写入"
          kill -15 $APP_PID
          
          echo "等待几秒钟，让进程优雅地终止..."
          sleep 5
          
          ls -lh 'jmalcloud.iprof'
          
          ls -lh 'jmalcloud.iprof'

      # 验证 Profile 文件是否已创建
      - name: Verify Profile File Creation
        run: |
          echo "Checking if profile file was created..."
          ls -l jmalcloud.iprof
          if [ ! -f "jmalcloud.iprof" ]; then
            echo "Error: Profile file jmalcloud.iprof was not created."
            exit 1
          fi

      # 使用传入参数构建最终优化的 Native Image
      - name: Build final PGO-Optimized Native Image
        run: |
          mvn clean package -Pnative -Daot.build.mode=${{ inputs.aot_build_mode }} -DskipTests -Dnative-image.jvmArgs="-Xmx15g" -Dnative-image.addArgs="--enable-monitoring=heapdump --pgo=jmalcloud.iprof"

      # 保存构建产物到本地共享目录
      - name: Save build artifacts to local cache
        id: save-cache
        run: |
          CACHE_DIR="/tmp/github-actions-build-cache/${{ github.run_id }}-${{ inputs.arch }}-${{ inputs.image_tag }}"
          echo "Creating cache directory: $CACHE_DIR"
          mkdir -p "$CACHE_DIR"
          
          echo "Copying build artifacts to cache..."
          cp -r target/ "$CACHE_DIR/"
          cp pom.xml "$CACHE_DIR/"
          
          echo "Cache directory contents:"
          ls -lah "$CACHE_DIR"
          
          # 保存缓存路径供下一个 job 使用
          echo "cache-dir=$CACHE_DIR" >> "$GITHUB_OUTPUT"
          echo "Build artifacts saved to: $CACHE_DIR"

  # Job 2: 创建临时 Docker 镜像来传递构建产物
  build-tmp-artifacts-image:
    needs: build-native-image
    runs-on: ${{ inputs.arch == 'amd64' && fromJSON('["self-hosted", "Linux", "X64"]') || fromJSON('["self-hosted", "Linux", "ARM64"]') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_USERNAME }}
          password: ${{ secrets.GHCR_IO_TOKEN }}

      # 从本地共享目录恢复构建产物
      - name: Restore build artifacts from local cache
        env:
          CACHE_DIR: ${{ needs.build-native-image.outputs.cache-dir }}
        run: |
          echo "Restoring from cache directory: $CACHE_DIR"
          
          if [ ! -d "$CACHE_DIR" ]; then
            echo "Error: Cache directory not found: $CACHE_DIR"
            exit 1
          fi
          
          echo "Cache directory contents:"
          ls -lah "$CACHE_DIR"
          
          echo "Copying artifacts from cache to workspace..."
          cp -r "$CACHE_DIR"/target/ ./
          cp "$CACHE_DIR"/pom.xml ./
          
          echo "Workspace after restore:"
          ls -lah .
          echo "Target directory:"
          ls -lah target/

      # 创建临时 Docker 镜像来传递构建产物
      - name: Build and push artifacts image
        run: |
          # 创建临时 Dockerfile，使用 busybox 作为基础镜像
          cat > Dockerfile.artifacts <<'EOF'
          FROM busybox:latest
          WORKDIR /artifacts
          COPY target/jmalcloud /artifacts/jmalcloud
          COPY target/*.so /artifacts/
          COPY pom.xml /artifacts/pom.xml
          CMD ["/bin/sh"]
          EOF
          
          # 构建并推送临时镜像
          docker build -f Dockerfile.artifacts -t ghcr.io/${{ secrets.GHCR_IO_USERNAME }}/jmalcloud-artifacts:${{ inputs.arch }}-${{ github.run_id }} .
          docker push ghcr.io/${{ secrets.GHCR_IO_USERNAME }}/jmalcloud-artifacts:${{ inputs.arch }}-${{ github.run_id }}
          
          echo "Artifacts image pushed successfully"

      # 清理本地缓存
      - name: Cleanup local cache
        if: always()
        env:
          CACHE_DIR: ${{ needs.build-native-image.outputs.cache-dir }}
        run: |
          if [ -d "$CACHE_DIR" ]; then
            echo "Removing cache directory: $CACHE_DIR"
            rm -rf "$CACHE_DIR"
          fi

  # Job 3: 在 GitHub runner 上构建前端、构建和推送 Docker 镜像
  build-docker-and-push:
    needs: build-tmp-artifacts-image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 构建前端
      - name: Checkout frontend
        uses: actions/checkout@v4
        with:
          repository: jamebal/jmal-cloud-view
          path: frontend

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}

      - name: Install frontend dependencies and Build
        working-directory: ./frontend
        run: |
          npm install
          npm run build:prod

      - name: Rename frontend dist
        working-directory: ./frontend
        run: |
          mkdir -p frontend
          mv dist/ frontend/
          mv frontend/dist/ frontend/frontend/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_USERNAME }}
          password: ${{ secrets.GHCR_IO_TOKEN }}

      # 从临时镜像中提取构建产物
      - name: Extract artifacts from Docker image
        run: |
          # 拉取镜像
          docker pull ghcr.io/${{ secrets.GHCR_IO_USERNAME }}/jmalcloud-artifacts:${{ inputs.arch }}-${{ github.run_id }}
          
          # 创建临时容器（使用 /bin/sh 作为命令）
          CONTAINER_ID=$(docker create ghcr.io/${{ secrets.GHCR_IO_USERNAME }}/jmalcloud-artifacts:${{ inputs.arch }}-${{ github.run_id }} /bin/sh)
          
          echo "Container ID: $CONTAINER_ID"
          
          # 创建 target 目录
          mkdir -p target
          
          # 从容器中复制文件
          docker cp $CONTAINER_ID:/artifacts/jmalcloud target/
          docker cp $CONTAINER_ID:/artifacts/pom.xml ./
          
          # 复制所有 .so 文件
          docker cp $CONTAINER_ID:/artifacts/ temp_artifacts/
          find temp_artifacts/ -name "*.so" -exec cp {} target/ \;
          rm -rf temp_artifacts/
          
          # 删除临时容器
          docker rm $CONTAINER_ID
          
          # 设置执行权限
          chmod +x target/jmalcloud
          
          echo "Extracted artifacts:"
          ls -lah target/
          ls -lah .

      # 设置 Maven
      - name: Set up Maven
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Extract project version from pom.xml
        id: project_version
        run: |
          VERSION=$(mvn -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive exec:exec)
          echo "PROJECT_VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Build and push arch-specific image
        uses: docker/build-push-action@v5
        with:
          context: .
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false
          file: ${{ inputs.dockerfile }}
          push: true
          tags: |
            jmal/${{ inputs.image_name }}:${{ inputs.image_tag }}-${{ inputs.arch }}
            ghcr.io/${{ secrets.GHCR_IO_USERNAME }}/${{ inputs.image_name }}:${{ inputs.image_tag }}-${{ inputs.arch }}
          platforms: linux/${{ inputs.arch }}
          build-args: |
            VERSION=${{ env.PROJECT_VERSION }}

      - name: Inspect the pushed image
        if: success()
        run: |
          echo "--- Inspecting Docker Hub image ---"
          docker manifest inspect jmal/${{ inputs.image_name }}:${{ inputs.image_tag }}-${{ inputs.arch }}

          echo "--- Inspecting GHCR image ---"
          docker manifest inspect ghcr.io/${{ secrets.GHCR_IO_USERNAME }}/${{ inputs.image_name }}:${{ inputs.image_tag }}-${{ inputs.arch }}

      # 清理临时 artifacts 镜像
      - name: Delete artifacts image
        if: always()
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GHCR_IO_TOKEN }}
        run: |
          # 使用 GitHub CLI 删除包版本
          echo "Attempting to delete artifacts package version..."
          
          # 获取包的所有版本
          PACKAGE_VERSIONS=$(curl -s \
            -H "Authorization: Bearer ${{ secrets.GHCR_IO_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/users/${{ secrets.GHCR_IO_USERNAME }}/packages/container/jmalcloud-artifacts/versions")
          
          echo "Package versions response:"
          echo "$PACKAGE_VERSIONS" | jq '.'
          
          # 查找并删除匹配的版本
          VERSION_ID=$(echo "$PACKAGE_VERSIONS" | jq -r ".[] | select(.metadata.container.tags[]? | contains(\"${{ inputs.arch }}-${{ github.run_id }}\")) | .id")
          
          if [ -n "$VERSION_ID" ]; then
            echo "Found version ID: $VERSION_ID"
            curl -X DELETE \
              -H "Authorization: Bearer ${{ secrets.GHCR_IO_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/users/${{ secrets.GHCR_IO_USERNAME }}/packages/container/jmalcloud-artifacts/versions/$VERSION_ID"
            echo "Artifacts image version deleted"
          else
            echo "No matching version found, skipping deletion"
          fi
